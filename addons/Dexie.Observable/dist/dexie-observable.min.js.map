{"version":3,"sources":["../src/utils.js","../src/override-create-transaction.js","../src/wakeup-observers.js","../src/hooks/creating.js","../src/hooks/updating.js","../src/hooks/deleting.js","../src/hooks/crud-monitor.js","../src/override-open.js","../src/intercomm.js","../src/override-parse-stores-spec.js","../src/delete-old-changes.js","../src/Dexie.Observable.js","../src/change_types.js","../src/on-storage.js"],"names":["promisableChain","f1","f2","nop","res","apply","this","arguments","then","thiz","args","createUUID","d","Date","now","replace","c","r","Math","random","floor","toString","db","wakeupObservers","origFunc","mode","storenames","dbschema","parent","dynamicallyOpened","addChanges","some","storeName","observable","slice","indexOf","push","trans","call","_lastWrittenRevision","on","rootTransaction","findRootTransaction","max","lastWrittenRevision","timeoutHandle","clearTimeout","setTimeout","source","Observable","localStorage","latestRevision","name","Dexie","ignoreTransaction","fire","setItem","table","primKey","obj","rv","undefined","schema","uuid","keyPath","setByKeyPath","change","key","type","CREATE","promise","_changes","add","rev","onsuccess","resultKey","_then","put","onerror","delete","tableName","mods","oldObj","modsWithoutUndefined","anythingChanged","newObj","deepClone","propPath","mod","delByKeyPath","currentValue","getByKeyPath","JSON","stringify","UPDATE","DELETE","catch","e","console","log","stack","hook","_observing","subscribe","initCreatingHook","initUpdatingHook","initDeletingHook","SyncNode","crudMonitor","origOpen","Object","keys","_allTables","forEach","mapToClass","initIntercomm","mySyncNode","consumeIntercommMessages","node","transaction","_intercomm","where","destinationNode","id","toArray","messages","msg","consumeMessage","anyOf","map","Promise","reject","DatabaseClosedError","request","requestsWaitingForReply","requestId","isFailure","message","error","resolve","result","sendMessage","sender","onIntercomm","dbname","options","wantReply","extend","tables","_syncNodes","equals","count","receiverAlive","above","first","masterNode","messageId","intercomm","broadcastMessage","bIncludeSelf","mySyncNodeId","nodes","all","filter","stores","dbSchema","substr","orderBy","oldestNode","below","myRevision","limit","primaryKeys","keysToDelete","length","bulkDelete","isOpen","deleteOldChanges","onLatestRevisionIncremented","handledRevision","vip","readChanges","recursion","wasPartial","ongoingOperation","partial","ourSyncNode","changes","lastChange","ourNodeStillExists","modify","syncNode","lastHeartBeat","deleteTimeStamp","browserIsShuttingDown","Error","close","global","location","reload","finally","heartbeat","heartbeatHandle","currentInstance","HEARTBEAT_INTERVAL","poll","pollHandle","cleanup","LOCAL_POLL","weBecameMaster","NODE_TIMEOUT","value","removeItem","isMaster","update","HIBERNATE_GRACE_PERIOD","onBeforeUnload","wereTheOneDying","onSuicide","nodeID","localStorageImpl","defineClass","Number","String","url","syncProtocol","syncContext","syncOptions","connected","status","appliedRemoteRevision","remoteBaseRevisions","local","remote","dbUploadState","tablesToUpload","currentTable","currentKey","localBaseRevision","initWakeupObservers","overrideCreateTransaction","initOverrideCreateTransaction","initCrudMonitor","overrideOpen","initOverrideOpen","defineProperty","get","fake","version","_uncommittedChanges","DatabaseChange","Version","prototype","_parseStoresSpec","override","overrideParseStoresSpec","addEventType","_createTransaction","open","origClose","unsubscribe","suicideNurseCall","origDelete","last","latestRevisionIncremented","currentMaster","self","Events","_onStorage","event","parts","split","prop","parseInt","newValue","isNaN","_onBeforeUnload","beforeunload","ex","addEventListener","addons"],"mappings":"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","file":"dist/dexie-observable.min.js","sourcesContent":["export function nop() {}\r\n\r\nexport function promisableChain(f1, f2) {\r\n  if (f1 === nop) return f2;\r\n  return function() {\r\n    var res = f1.apply(this, arguments);\r\n    if (res && typeof res.then === 'function') {\r\n      var thiz = this, args = arguments;\r\n      return res.then(function() {\r\n        return f2.apply(thiz, args);\r\n      });\r\n    }\r\n    return f2.apply(this, arguments);\r\n  };\r\n}\r\n\r\nexport function createUUID() {\r\n  // Decent solution from http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript\r\n  var d = Date.now();\r\n  var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\r\n    var r = (d + Math.random() * 16) % 16 | 0;\r\n    d = Math.floor(d / 16);\r\n    return (c === 'x' ? r : (r & 0x7 | 0x8)).toString(16);\r\n  });\r\n  return uuid;\r\n}\r\n","export default function initOverrideCreateTransaction(db, wakeupObservers) {\r\n  return function overrideCreateTransaction(origFunc) {\r\n    return function (mode, storenames, dbschema, parent) {\r\n      if (db.dynamicallyOpened()) return origFunc.apply(this, arguments); // Don't observe dynamically opened databases.\r\n      var addChanges = false;\r\n      if (mode === 'readwrite' && storenames.some(function (storeName) {\r\n            return dbschema[storeName] && dbschema[storeName].observable;\r\n          })) {\r\n        // At least one included store is a observable store. Make sure to also include the _changes store.\r\n        addChanges = true;\r\n        storenames = storenames.slice(0); // Clone\r\n        if (storenames.indexOf(\"_changes\") === -1)\r\n          storenames.push(\"_changes\"); // Otherwise, firefox will hang... (I've reported the bug to Mozilla@Bugzilla)\r\n      }\r\n      // Call original db._createTransaction()\r\n      var trans = origFunc.call(this, mode, storenames, dbschema, parent);\r\n      // If this transaction is bound to any observable table, make sure to add changes when transaction completes.\r\n      if (addChanges) {\r\n        trans._lastWrittenRevision = 0;\r\n        trans.on('complete', function () {\r\n          if (trans._lastWrittenRevision) {\r\n            // Changes were written in this transaction.\r\n            if (!parent) {\r\n              // This is root-level transaction, i.e. a physical commit has happened.\r\n              // Delay-trigger a wakeup call:\r\n              if (wakeupObservers.timeoutHandle) clearTimeout(wakeupObservers.timeoutHandle);\r\n              wakeupObservers.timeoutHandle = setTimeout(function () {\r\n                delete wakeupObservers.timeoutHandle;\r\n                wakeupObservers(trans._lastWrittenRevision);\r\n              }, 25);\r\n            } else {\r\n              // This is just a virtual commit of a sub transaction.\r\n              // Wait with waking up observers until root transaction has committed.\r\n              // Make sure to mark root transaction so that it will wakeup observers upon commit.\r\n              var rootTransaction = (function findRootTransaction(trans) {\r\n                return trans.parent ? findRootTransaction(trans.parent) : trans;\r\n              })(parent);\r\n              rootTransaction._lastWrittenRevision = Math.max(\r\n                  trans._lastWrittenRevision,\r\n                  rootTransaction.lastWrittenRevision || 0);\r\n            }\r\n          }\r\n        });\r\n        // Derive \"source\" property from parent transaction by default\r\n        if (trans.parent && trans.parent.source) trans.source = trans.parent.source;\r\n      }\r\n      return trans;\r\n    };\r\n  };\r\n}\r\n","import Dexie from 'dexie';\r\n\r\nexport default function initWakeupObservers(db, Observable, localStorage) {\r\n  return function wakeupObservers(lastWrittenRevision) {\r\n    // Make sure Observable.latestRevision[db.name] is still below our value, now when some time has elapsed and other db instances in same window possibly could have made changes too.\r\n    if (Observable.latestRevision[db.name] < lastWrittenRevision) {\r\n      // Set the static property lastRevision[db.name] to the revision of the last written change.\r\n      Observable.latestRevision[db.name] = lastWrittenRevision;\r\n      // Wakeup ourselves, and any other db instances on this window:\r\n      Dexie.ignoreTransaction(function () {\r\n        Observable.on('latestRevisionIncremented').fire(db.name, lastWrittenRevision);\r\n      });\r\n      // Observable.on.latestRevisionIncremented will only wakeup db's in current window.\r\n      // We need a storage event to wakeup other windwos.\r\n      // Since indexedDB lacks storage events, let's use the storage event from WebStorage just for\r\n      // the purpose to wakeup db instances in other windows.\r\n      if (localStorage) localStorage.setItem('Dexie.Observable/latestRevision/' + db.name, lastWrittenRevision); // In IE, this will also wakeup our own window. However, onLatestRevisionIncremented will work around this by only running once per revision id.\r\n    }\r\n  };\r\n}\r\n","import Dexie from 'dexie';\r\n\r\nimport {CREATE} from '../change_types';\r\nimport {createUUID} from '../utils';\r\n\r\nexport default function initCreatingHook(db, table) {\r\n  return function creatingHook(primKey, obj, trans) {\r\n    /// <param name=\"trans\" type=\"db.Transaction\"></param>\r\n    var rv = undefined;\r\n    if (primKey === undefined && table.schema.primKey.uuid) {\r\n      primKey = rv = createUUID();\r\n      if (table.schema.primKey.keyPath) {\r\n        Dexie.setByKeyPath(obj, table.schema.primKey.keyPath, primKey);\r\n      }\r\n    }\r\n\r\n    var change = {\r\n      source: trans.source || null, // If a \"source\" is marked on the transaction, store it. Useful for observers that want to ignore their own changes.\r\n      table: table.name,\r\n      key: primKey === undefined ? null : primKey,\r\n      type: CREATE,\r\n      obj: obj\r\n    };\r\n\r\n    var promise = db._changes.add(change).then(function (rev) {\r\n      trans._lastWrittenRevision = Math.max(trans._lastWrittenRevision, rev);\r\n      return rev;\r\n    });\r\n\r\n    // Wait for onsuccess so that we have the primKey if it is auto-incremented and update the change item if so.\r\n    this.onsuccess = function (resultKey) {\r\n      if (primKey != resultKey)\r\n        promise._then(function () {\r\n          change.key = resultKey;\r\n          db._changes.put(change);\r\n        });\r\n    };\r\n\r\n    this.onerror = function () {\r\n      // If the main operation fails, make sure to regret the change\r\n      promise._then(function (rev) {\r\n        // Will only happen if app code catches the main operation error to prohibit transaction from aborting.\r\n        db._changes.delete(rev);\r\n      });\r\n    };\r\n\r\n    return rv;\r\n  };\r\n}\r\n","import Dexie from 'dexie';\r\n\r\nimport {UPDATE} from '../change_types';\r\n\r\nexport default function initUpdatingHook(db, tableName) {\r\n  return function updatingHook(mods, primKey, oldObj, trans) {\r\n    /// <param name=\"trans\" type=\"db.Transaction\"></param>\r\n    // mods may contain property paths with undefined as value if the property\r\n    // is being deleted. Since we cannot persist undefined we need to act\r\n    // like those changes is setting the value to null instead.\r\n    var modsWithoutUndefined = {};\r\n    // As of current Dexie version (1.0.3) hook may be called even if it wouldn't really change.\r\n    // Therefore we may do that kind of optimization here - to not add change entries if\r\n    // there's nothing to change.\r\n    var anythingChanged = false;\r\n    var newObj = Dexie.deepClone(oldObj);\r\n    for (var propPath in mods) {\r\n      var mod = mods[propPath];\r\n      if (typeof mod === 'undefined') {\r\n        Dexie.delByKeyPath(newObj, propPath);\r\n        modsWithoutUndefined[propPath] = null; // Null is as close we could come to deleting a property when not allowing undefined.\r\n        anythingChanged = true;\r\n      } else {\r\n        var currentValue = Dexie.getByKeyPath(oldObj, propPath);\r\n        if (mod !== currentValue && JSON.stringify(mod) !== JSON.stringify(currentValue)) {\r\n          Dexie.setByKeyPath(newObj, propPath, mod);\r\n          modsWithoutUndefined[propPath] = mod;\r\n          anythingChanged = true;\r\n        }\r\n      }\r\n    }\r\n    if (anythingChanged) {\r\n      var change = {\r\n        source: trans.source || null, // If a \"source\" is marked on the transaction, store it. Useful for observers that want to ignore their own changes.\r\n        table: tableName,\r\n        key: primKey,\r\n        type: UPDATE,\r\n        mods: modsWithoutUndefined,\r\n        oldObj: oldObj,\r\n        obj: newObj\r\n      };\r\n      var promise = db._changes.add(change); // Just so we get the correct revision order of the update...\r\n      this.onsuccess = function () {\r\n        promise._then(function (rev) {\r\n          trans._lastWrittenRevision = Math.max(trans._lastWrittenRevision, rev);\r\n        });\r\n      };\r\n      this.onerror = function () {\r\n        // If the main operation fails, make sure to regret the change.\r\n        promise._then(function (rev) {\r\n          // Will only happen if app code catches the main operation error to prohibit transaction from aborting.\r\n          db._changes.delete(rev);\r\n        });\r\n      };\r\n    }\r\n  };\r\n}\r\n","import {DELETE} from '../change_types';\r\n\r\nexport default function initDeletingHook(db, tableName) {\r\n  return function deletingHook(primKey, obj, trans) {\r\n    /// <param name=\"trans\" type=\"db.Transaction\"></param>\r\n    var promise = db._changes.add({\r\n      source: trans.source || null, // If a \"source\" is marked on the transaction, store it. Useful for observers that want to ignore their own changes.\r\n      table: tableName,\r\n      key: primKey,\r\n      type: DELETE,\r\n      oldObj: obj\r\n    }).then(function (rev) {\r\n      trans._lastWrittenRevision = Math.max(trans._lastWrittenRevision, rev);\r\n      return rev;\r\n    })\r\n        .catch((e) => {\r\n          console.log(obj)\r\n          console.log(e.stack)\r\n        })\r\n    this.onerror = function () {\r\n      // If the main operation fails, make sure to regret the change.\r\n      // Using _then because if promise is already fullfilled, the standard then() would\r\n      // do setTimeout() and we would loose the transaction.\r\n      promise._then(function (rev) {\r\n        // Will only happen if app code catches the main operation error to prohibit transaction from aborting.\r\n        db._changes.delete(rev);\r\n      });\r\n    };\r\n  };\r\n}\r\n","import initCreatingHook from './creating';\r\nimport initUpdatingHook from './updating';\r\nimport initDeletingHook from './deleting';\r\n\r\nexport default function initCrudMonitor(db) {\r\n//\r\n// The Creating/Updating/Deleting hook will make sure any change is stored to the changes table\r\n//\r\n  return function crudMonitor(table) {\r\n    /// <param name=\"table\" type=\"db.Table\"></param>\r\n    if (table.hook._observing) return;\r\n    table.hook._observing = true;\r\n\r\n    const tableName = table.name;\r\n    table.hook('creating').subscribe(initCreatingHook(db, table));\r\n\r\n    table.hook('updating').subscribe(initUpdatingHook(db, tableName));\r\n\r\n    table.hook('deleting').subscribe(initDeletingHook(db, tableName));\r\n  };\r\n}\r\n","export default function initOverrideOpen(db, SyncNode, crudMonitor) {\r\n  return function overrideOpen(origOpen) {\r\n    return function () {\r\n      //\r\n      // Make sure to subscribe to \"creating\", \"updating\" and \"deleting\" hooks for all observable tables that were created in the stores() method.\r\n      //\r\n      Object.keys(db._allTables).forEach(tableName => {\r\n        let table = db._allTables[tableName];\r\n        if (table.schema.observable) {\r\n          crudMonitor(table);\r\n        }\r\n        if (table.name === \"_syncNodes\") {\r\n          table.mapToClass(SyncNode);\r\n        }\r\n      });\r\n      return origOpen.apply(this, arguments);\r\n    }\r\n  };\r\n}\r\n","import Dexie from 'dexie';\r\n\r\nconst Promise = Dexie.Promise;\r\n\r\nexport default function initIntercomm(db, Observable, SyncNode, mySyncNode, localStorage) {\r\n//\r\n// Intercommunication between nodes\r\n//\r\n// Enable inter-process communication between browser windows using localStorage storage event (is registered in Dexie.Observable)\r\n\r\n  var requestsWaitingForReply = {};\r\n\r\n  /**\r\n   * @param {string} type Type of message\r\n   * @param message Message to send\r\n   * @param {number} destinationNode ID of destination node\r\n   * @param {{wantReply: boolean, isFailure: boolean, requestId: number}} options If {wantReply: true}, the returned promise will complete with the reply from remote. Otherwise it will complete when message has been successfully sent.</param>\r\n   */\r\n  db.observable.sendMessage = function (type, message, destinationNode, options) {\r\n    /// <param name=\"type\" type=\"String\">Type of message</param>\r\n    /// <param name=\"message\">Message to send</param>\r\n    /// <param name=\"destinationNode\" type=\"Number\">ID of destination node</param>\r\n    /// <param name=\"options\" type=\"Object\" optional=\"true\">{wantReply: Boolean, isFailure: Boolean, requestId: Number}. If wantReply, the returned promise will complete with the reply from remote. Otherwise it will complete when message has been successfully sent.</param>\r\n    options = options || {};\r\n    if (!mySyncNode.node)\r\n      return options.wantReply ?\r\n          Promise.reject(new Dexie.DatabaseClosedError()) :\r\n          Promise.resolve(); // If caller doesn't want a reply, it won't catch errors either.\r\n\r\n    var msg = {message: message, destinationNode: destinationNode, sender: mySyncNode.node.id, type: type};\r\n    Dexie.extend(msg, options); // wantReply: wantReply, success: !isFailure, requestId: ...\r\n    return Dexie.ignoreTransaction(()=> {\r\n      var tables = [\"_intercomm\"];\r\n      if (options.wantReply) tables.push(\"_syncNodes\"); // If caller wants a reply, include \"_syncNodes\" in transaction to check that there's a receiver there. Otherwise, new master will get it.\r\n      var promise = db.transaction('rw', tables, () => {\r\n        if (options.wantReply) {\r\n          // Check that there is a receiver there to take the request.\r\n          return db._syncNodes.where('id').equals(destinationNode).count(receiverAlive => {\r\n            if (receiverAlive)\r\n              return db._intercomm.add(msg);\r\n            else // If we couldn't find a node -> send to master\r\n              return db._syncNodes.where('isMaster').above(0).first(function (masterNode) {\r\n                msg.destinationNode = masterNode.id;\r\n                return db._intercomm.add(msg)\r\n              });\r\n          });\r\n        } else {\r\n          // If caller doesn't need a response, we don't have to make sure that it gets one.\r\n          return db._intercomm.add(msg);\r\n        }\r\n      }).then(messageId => {\r\n        var rv = null;\r\n        if (options.wantReply) {\r\n          rv = new Promise(function (resolve, reject) {\r\n            requestsWaitingForReply[messageId.toString()] = {resolve: resolve, reject: reject};\r\n          });\r\n        }\r\n        if (localStorage) {\r\n          localStorage.setItem(\"Dexie.Observable/intercomm/\" + db.name, messageId.toString());\r\n        }\r\n        Observable.on.intercomm.fire(db.name);\r\n        return rv;\r\n      });\r\n\r\n      if (!options.wantReply) {\r\n        promise.catch(()=> {\r\n        });\r\n        return;\r\n      } else {\r\n        // Forward rejection to caller if it waits for reply.\r\n        return promise;\r\n      }\r\n    });\r\n  };\r\n\r\n  // Send a message to all local _syncNodes\r\n  db.observable.broadcastMessage = function (type, message, bIncludeSelf) {\r\n    if (!mySyncNode.node) return;\r\n    var mySyncNodeId = mySyncNode.node.id;\r\n    Dexie.ignoreTransaction(()=> {\r\n      db._syncNodes.toArray(nodes => {\r\n        return Promise.all(nodes\r\n            .filter(node => node.type === 'local' && (bIncludeSelf || node.id !== mySyncNodeId))\r\n            .map(node => db.observable.sendMessage(type, message, node.id)));\r\n      }).catch(()=> {\r\n      });\r\n    });\r\n  };\r\n\r\n  function consumeIntercommMessages() {\r\n    // Check if we got messages:\r\n    if (!mySyncNode.node) return Promise.reject(new Dexie.DatabaseClosedError());\r\n\r\n    return Dexie.ignoreTransaction(()=> {\r\n      return db.transaction('rw', '_intercomm', function() {\r\n        return db._intercomm.where({destinationNode: mySyncNode.node.id}).toArray(messages => {\r\n          messages.forEach(msg => consumeMessage(msg));\r\n          return db._intercomm.where('id').anyOf(messages.map(msg => msg.id)).delete();\r\n        });\r\n      });\r\n    });\r\n  }\r\n\r\n  function consumeMessage(msg) {\r\n    if (msg.type === 'response') {\r\n      // This is a response. Lookup pending request and fulfill its promise.\r\n      var request = requestsWaitingForReply[msg.requestId.toString()];\r\n      if (request) {\r\n        if (msg.isFailure) {\r\n          request.reject(msg.message.error);\r\n        } else {\r\n          request.resolve(msg.message.result);\r\n        }\r\n        delete requestsWaitingForReply[msg.requestId.toString()];\r\n      }\r\n    } else {\r\n      // This is a message or request. Fire the event and add an API for the subscriber to use if reply is requested\r\n      msg.resolve = function (result) {\r\n        db.observable.sendMessage('response', {result: result}, msg.sender, {requestId: msg.id});\r\n      };\r\n      msg.reject = function (error) {\r\n        db.observable.sendMessage('response', {error: error.toString()}, msg.sender, {isFailure: true, requestId: msg.id});\r\n      };\r\n      db.on.message.fire(msg);\r\n    }\r\n  }\r\n\r\n  // Listener for 'intercomm' events\r\n  // Gets fired when we get a 'storage' event from local storage or when sendMessage is called\r\n  // 'storage' is used to communicate between tabs (sendMessage changes the localStorage to trigger the event)\r\n  // sendMessage is used to communicate in the same tab and to trigger a storage event\r\n  function onIntercomm(dbname) {\r\n    // When storage event trigger us to check\r\n    if (dbname === db.name) {\r\n      consumeIntercommMessages().catch('DatabaseClosedError', ()=> {});\r\n    }\r\n  }\r\n\r\n  return {\r\n    onIntercomm,\r\n    consumeIntercommMessages\r\n  };\r\n}\r\n","export default function overrideParseStoresSpec(origFunc) {\r\n  return function(stores, dbSchema) {\r\n    // Create the _changes and _syncNodes tables\r\n    stores[\"_changes\"] = \"++rev\";\r\n    stores[\"_syncNodes\"] = \"++id,myRevision,lastHeartBeat,&url,isMaster,type,status\";\r\n    stores[\"_intercomm\"] = \"++id,destinationNode\";\r\n    stores[\"_uncommittedChanges\"] = \"++id,node\"; // For remote syncing when server returns a partial result.\r\n    // Call default implementation. Will populate the dbSchema structures.\r\n    origFunc.call(this, stores, dbSchema);\r\n    // Allow UUID primary keys using $$ prefix on primary key or indexes\r\n    Object.keys(dbSchema).forEach(function(tableName) {\r\n      var schema = dbSchema[tableName];\r\n      if (schema.primKey.name.indexOf('$$') === 0) {\r\n        schema.primKey.uuid = true;\r\n        schema.primKey.name = schema.primKey.name.substr(2);\r\n        schema.primKey.keyPath = schema.primKey.keyPath.substr(2);\r\n      }\r\n    });\r\n    // Now mark all observable tables\r\n    Object.keys(dbSchema).forEach(function(tableName) {\r\n      // Marked observable tables with \"observable\" in their TableSchema.\r\n      if (tableName.indexOf('_') !== 0 && tableName.indexOf('$') !== 0) {\r\n        dbSchema[tableName].observable = true;\r\n      }\r\n    });\r\n  };\r\n}\r\n","import Dexie from 'dexie';\r\n\r\nexport default function deleteOldChanges(db) {\r\n  // This is a background job and should never be done within\r\n  // a caller's transaction. Use Dexie.ignoreTransaction() to ensure that.\r\n  // We should not return the Promise but catch it ourselves instead.\r\n\r\n  // To prohibit starving the database we want to lock transactions as short as possible\r\n  // and since we're not in a hurry, we could do this job in chunks and reschedule a\r\n  // continuation every 500 ms.\r\n  const CHUNK_SIZE = 100;\r\n\r\n  Dexie.ignoreTransaction(()=>{\r\n    return db._syncNodes.orderBy(\"myRevision\").first(oldestNode => {\r\n      return db._changes\r\n          .where(\"rev\").below(oldestNode.myRevision)\r\n          .limit(CHUNK_SIZE)\r\n          .primaryKeys();\r\n    }).then(keysToDelete => {\r\n      if (keysToDelete.length === 0) return; // Done.\r\n      return db._changes.bulkDelete(keysToDelete).then(()=> {\r\n        // If not done garbage collecting, reschedule a continuation of it until done.\r\n        if (keysToDelete.length === CHUNK_SIZE) {\r\n          // Limit reached. Changes are there are more job to do. Schedule again:\r\n          setTimeout(() => db.isOpen() && deleteOldChanges(db), 500);\r\n        }\r\n      });\r\n    });\r\n  }).catch(()=>{\r\n    // The operation is not crucial. A failure could almost only be due to that database has been closed.\r\n    // No need to log this.\r\n  });\r\n}\r\n","/* ========================================================================== \r\n *                           dexie-observable.js\r\n * ==========================================================================\r\n *\r\n * Dexie addon for observing database changes not just on local db instance\r\n * but also on other instances, tabs and windows.\r\n *\r\n * Comprises a base framework for dexie-syncable.js\r\n *\r\n * By David Fahlander, david.fahlander@gmail.com,\r\n *    Nikolas Poniros, https://github.com/nponiros\r\n *\r\n * ==========================================================================\r\n *\r\n * Version {version}, {date}\r\n *\r\n * http://dexie.org\r\n *\r\n * Apache License Version 2.0, January 2004, http://www.apache.org/licenses/\r\n * \r\n */\r\nimport Dexie from 'dexie';\r\nimport { nop, promisableChain, createUUID } from './utils';\r\n\r\nimport initOverrideCreateTransaction from './override-create-transaction';\r\nimport initWakeupObservers from './wakeup-observers';\r\nimport initCrudMonitor from './hooks/crud-monitor';\r\nimport initOnStorage from './on-storage';\r\nimport initOverrideOpen from './override-open';\r\nimport initIntercomm from './intercomm';\r\n\r\nimport overrideParseStoresSpec from './override-parse-stores-spec';\r\n\r\nimport deleteOldChanges from './delete-old-changes';\r\n\r\nvar global = self;\r\n\r\n/** class DatabaseChange\r\n    *\r\n    *  Object contained by the _changes table.\r\n    */\r\nvar DatabaseChange = Dexie.defineClass({\r\n    rev: Number, // Auto-incremented primary key\r\n    source: String, // Optional source creating the change. Set if transaction.source was set when doing the operation.\r\n    table: String, // Table name\r\n    key: Object, // Primary key. Any type.\r\n    type: Number, // 1 = CREATE, 2 = UPDATE, 3 = DELETE\r\n    obj: Object, // CREATE: obj contains the object created.\r\n    mods: Object, // UPDATE: mods contains the modifications made to the object.\r\n    oldObj: Object // DELETE: oldObj contains the object deleted. UPDATE: oldObj contains the old object before updates applied.\r\n});\r\n\r\n// Import some usable helper functions\r\nvar override = Dexie.override;\r\nvar Promise = Dexie.Promise;\r\nvar browserIsShuttingDown = false;\r\n\r\nexport default function Observable(db) {\r\n    /// <summary>\r\n    ///   Extension to Dexie providing Syncronization capabilities to Dexie.\r\n    /// </summary>\r\n    /// <param name=\"db\" type=\"Dexie\"></param>\r\n\r\n    var NODE_TIMEOUT = 20000, // 20 seconds before local db instances are timed out. This is so that old changes can be deleted when not needed and to garbage collect old _syncNodes objects.\r\n        HIBERNATE_GRACE_PERIOD = 20000, // 20 seconds\r\n        // LOCAL_POLL: The time to wait before polling local db for changes and cleaning up old nodes. \r\n        // Polling for changes is a fallback only needed in certain circomstances (when the onstorage event doesnt reach all listeners - when different browser windows doesnt share the same process)\r\n        LOCAL_POLL = 500, // 500 ms. In real-world there will be this value + the time it takes to poll(). A small value is needed in Workers where we cannot rely on storage event.\r\n        HEARTBEAT_INTERVAL = NODE_TIMEOUT - 5000;\r\n\r\n    var localStorage = Observable.localStorageImpl;\r\n\r\n    /** class SyncNode\r\n        *\r\n        * Object contained in the _syncNodes table.\r\n        */\r\n    var SyncNode = Dexie.defineClass({\r\n        //id: Number,\r\n        myRevision: Number,\r\n        type: String, // \"local\" or \"remote\"\r\n        lastHeartBeat: Number,\r\n        deleteTimeStamp: Number, // In case lastHeartBeat is too old, a value of now + HIBERNATE_GRACE_PERIOD will be set here. If reached before node wakes up, node will be deleted.\r\n        url: String, // Only applicable for \"remote\" nodes. Only used in Dexie.Syncable.\r\n        isMaster: Number, // 1 if true. Not using Boolean because it's not possible to index Booleans in IE implementation of IDB.\r\n\r\n        // Below properties should be extended in Dexie.Syncable. Not here. They apply to remote nodes only (type == \"remote\"):\r\n        syncProtocol: String, // Tells which implementation of ISyncProtocol to use for remote syncing. \r\n        syncContext: null,\r\n        syncOptions: Object,\r\n        connected: false, // FIXTHIS: Remove! Replace with status.\r\n        status: Number,\r\n        appliedRemoteRevision: null,\r\n        remoteBaseRevisions: [{ local: Number, remote: null }],\r\n        dbUploadState: {\r\n            tablesToUpload: [String],\r\n            currentTable: String,\r\n            currentKey: null,\r\n            localBaseRevision: Number\r\n        }\r\n    });\r\n\r\n    db.observable = {};\r\n    db.observable.SyncNode = SyncNode;\r\n\r\n    const wakeupObservers = initWakeupObservers(db, Observable, localStorage);\r\n    const overrideCreateTransaction = initOverrideCreateTransaction(db, wakeupObservers);\r\n    const crudMonitor = initCrudMonitor(db);\r\n    const overrideOpen = initOverrideOpen(db, SyncNode, crudMonitor);\r\n\r\n    var mySyncNode = {node: null};\r\n\r\n    const intercomm = initIntercomm(db, Observable, SyncNode, mySyncNode, localStorage);\r\n    const onIntercomm = intercomm.onIntercomm;\r\n    const consumeIntercommMessages = intercomm.consumeIntercommMessages;\r\n\r\n    // Allow other addons to access the local sync node. May be needed by Dexie.Syncable.\r\n    Object.defineProperty(db, \"_localSyncNode\", {\r\n        get: function() { return mySyncNode.node; }\r\n    });\r\n\r\n    var pollHandle = null,\r\n        heartbeatHandle = null;\r\n\r\n    if (Dexie.fake) {\r\n        // This code will never run.\r\n        // It's here just to enable auto-complete in visual studio - helps a lot when writing code.\r\n        db.version(1).stores({\r\n            _syncNodes: \"++id,myRevision,lastHeartBeat\",\r\n            _changes: \"++rev\",\r\n            _intercomm: \"++id,destinationNode\",\r\n            _uncommittedChanges: \"++id,node\"\r\n        });\r\n        db._syncNodes.mapToClass(SyncNode);\r\n        db._changes.mapToClass(DatabaseChange);\r\n        mySyncNode.node = new SyncNode({\r\n            myRevision: 0,\r\n            type: \"local\",\r\n            lastHeartBeat: Date.now(),\r\n            deleteTimeStamp: null\r\n        });\r\n    }\r\n\r\n    //\r\n    // Override parsing the stores to add \"_changes\" and \"_syncNodes\" tables.\r\n    // It also adds UUID support for the primary key and sets tables as observable tables.\r\n    //\r\n    db.Version.prototype._parseStoresSpec = override(db.Version.prototype._parseStoresSpec, overrideParseStoresSpec);\r\n\r\n    // changes event on db:\r\n    db.on.addEventType({\r\n        changes: 'asap',\r\n        cleanup: [promisableChain, nop], // fire (nodesTable, changesTable, trans). Hook called when cleaning up nodes. Subscribers may return a Promise to to more stuff. May do additional stuff if local sync node is master.\r\n        message: 'asap'\r\n    });\r\n\r\n    //\r\n    // Override transaction creation to always include the \"_changes\" store when any observable store is involved.\r\n    //\r\n    db._createTransaction = override(db._createTransaction, overrideCreateTransaction);\r\n\r\n    // If Observable.latestRevsion[db.name] is undefined, set it to 0 so that comparing against it always works.\r\n    // You might think that it will always be undefined before this call, but in case another Dexie instance in the same\r\n    // window with the same database name has been created already, this static property will already be set correctly.\r\n    Observable.latestRevision[db.name] = Observable.latestRevision[db.name] || 0;\r\n\r\n    //\r\n    // Override open to setup hooks for db changes and map the _syncNodes table to class\r\n    //\r\n    db.open = override(db.open, overrideOpen);\r\n\r\n    db.close = override(db.close, function(origClose) {\r\n        return function () {\r\n            if (db.dynamicallyOpened()) return origClose.apply(this, arguments); // Don't observe dynamically opened databases.\r\n            // Teardown our framework.\r\n            if (wakeupObservers.timeoutHandle) {\r\n                clearTimeout(wakeupObservers.timeoutHandle);\r\n                delete wakeupObservers.timeoutHandle;\r\n            }\r\n            Observable.on('latestRevisionIncremented').unsubscribe(onLatestRevisionIncremented);\r\n            Observable.on('suicideNurseCall').unsubscribe(onSuicide);\r\n            Observable.on('intercomm').unsubscribe(onIntercomm);\r\n            Observable.on('beforeunload').unsubscribe(onBeforeUnload);\r\n            // Inform other db instances in same window that we are dying:\r\n            if (mySyncNode.node && mySyncNode.node.id) {\r\n                Observable.on.suicideNurseCall.fire(db.name, mySyncNode.node.id);\r\n                // Inform other windows as well:\r\n                if (localStorage) {\r\n                    localStorage.setItem('Dexie.Observable/deadnode:' + mySyncNode.node.id.toString() + '/' + db.name, \"dead\"); // In IE, this will also wakeup our own window. cleanup() may trigger twice per other db instance. But that doesnt to anything.\r\n                }\r\n                mySyncNode.node.deleteTimeStamp = 1; // One millisecond after 1970. Makes it occur in the past but still keeps it truthy.\r\n                mySyncNode.node.lastHeartBeat = 0;\r\n                db._syncNodes.put(mySyncNode.node); // This async operation may be cancelled since the browser is closing down now.\r\n                mySyncNode.node = null;\r\n            }\r\n\r\n            if (pollHandle) clearTimeout(pollHandle);\r\n            pollHandle = null;\r\n            if (heartbeatHandle) clearTimeout(heartbeatHandle);\r\n            heartbeatHandle = null;\r\n            return origClose.apply(this, arguments);\r\n        };\r\n    });\r\n\r\n    // Override Dexie.delete() in order to delete Observable.latestRevision[db.name].\r\n    db.delete = override(db.delete, function(origDelete) {\r\n        return function() {\r\n            return origDelete.apply(this, arguments).then(function(result) {\r\n                // Reset Observable.latestRevision[db.name]\r\n                Observable.latestRevision[db.name] = 0;\r\n                return result;\r\n            });\r\n        };\r\n    });\r\n\r\n    // When db opens, make sure to start monitor any changes before other db operations will start.\r\n    db.on(\"ready\", function startObserving() {\r\n        if (db.dynamicallyOpened()) return db; // Don't observe dynamically opened databases.\r\n        \r\n        return db.table(\"_changes\").orderBy(\"rev\").last(function(lastChange) {\r\n            // Since startObserving() is called before database open() method, this will be the first database operation enqueued to db.\r\n            // Therefore we know that the retrieved value will be This query will\r\n            var latestRevision = (lastChange ? lastChange.rev : 0);\r\n            mySyncNode.node = new SyncNode({\r\n                myRevision: latestRevision,\r\n                type: \"local\",\r\n                lastHeartBeat: Date.now(),\r\n                deleteTimeStamp: null,\r\n                isMaster: 0\r\n            });\r\n            if (Observable.latestRevision[db.name] < latestRevision) {\r\n                // Side track . For correctness whenever setting Observable.latestRevision[db.name] we must make sure the event is fired if increased:\r\n                // There are other db instances in same window that hasnt yet been informed about a new revision\r\n                Observable.latestRevision[db.name] = latestRevision;\r\n                Dexie.ignoreTransaction(function() {\r\n                    Observable.on.latestRevisionIncremented.fire(latestRevision);\r\n                });\r\n            }\r\n            // Add new sync node or if this is a reopening of the database after a close() call, update it.\r\n            return db.transaction('rw', '_syncNodes', () => {\r\n                return db._syncNodes\r\n                    .where('isMaster').equals(1)\r\n                    .first(currentMaster => {\r\n                        if (!currentMaster) {\r\n                            // There's no master. We must be the master\r\n                            mySyncNode.node.isMaster = 1;\r\n                        } else if (currentMaster.lastHeartBeat < Date.now() - NODE_TIMEOUT) {\r\n                            // Master have been inactive for too long\r\n                            // Take over mastership\r\n                            mySyncNode.node.isMaster = 1;\r\n                            currentMaster.isMaster = 0;\r\n                            return db._syncNodes.put(currentMaster);\r\n                        }\r\n                    }).then(()=>{\r\n                        // Add our node to DB and start subscribing to events\r\n                        return db._syncNodes.add(mySyncNode.node).then(function() {\r\n                            Observable.on('latestRevisionIncremented', onLatestRevisionIncremented); // Wakeup when a new revision is available.\r\n                            Observable.on('beforeunload', onBeforeUnload);\r\n                            Observable.on('suicideNurseCall', onSuicide);\r\n                            Observable.on('intercomm', onIntercomm);\r\n                            // Start polling for changes and do cleanups:\r\n                            pollHandle = setTimeout(poll, LOCAL_POLL);\r\n                            // Start heartbeat\r\n                            heartbeatHandle = setTimeout(heartbeat, HEARTBEAT_INTERVAL);\r\n                        });\r\n                });\r\n            }).then(function () {\r\n                cleanup();\r\n            });\r\n        });\r\n    }, true); // True means the on(ready) event will survive a db reopening (db.close() / db.open()).\r\n\r\n    var handledRevision = 0;\r\n\r\n    function onLatestRevisionIncremented(dbname, latestRevision) {\r\n        if (dbname === db.name) {\r\n            if (handledRevision >= latestRevision) return; // Make sure to only run once per revision. (Workaround for IE triggering storage event on same window)\r\n            handledRevision = latestRevision;\r\n            Dexie.vip(function() {\r\n                readChanges(latestRevision).catch('DatabaseClosedError', ()=>{\r\n                    // Handle database closed error gracefully while reading changes.\r\n                    // Don't trigger 'unhandledrejection'.\r\n                    // Even though we intercept the close() method, it might be called when in the middle of\r\n                    // reading changes and then that flow will cancel with DatabaseClosedError.\r\n                });\r\n            });\r\n        }\r\n    }\r\n\r\n    function readChanges(latestRevision, recursion, wasPartial) {\r\n        // Whenever changes are read, fire db.on(\"changes\") with the array of changes. Eventually, limit the array to 1000 entries or so (an entire database is\r\n        // downloaded from server AFTER we are initiated. For example, if first sync call fails, then after a while we get reconnected. However, that scenario\r\n        // should be handled in case database is totally empty we should fail if sync is not available)\r\n        if (!recursion && readChanges.ongoingOperation) {\r\n            // We are already reading changes. Prohibit a parallell execution of this which would lead to duplicate trigging of 'changes' event.\r\n            // Instead, the callback in toArray() will always check Observable.latestRevision[db.name] to see if it has changed and if so, re-launch readChanges().\r\n            // The caller should get the Promise instance from the ongoing operation so that the then() method will resolve when operation is finished.\r\n            return readChanges.ongoingOperation;\r\n        }\r\n\r\n        var partial = false;\r\n        var ourSyncNode = mySyncNode.node; // Because mySyncNode can suddenly be set to null on database close, and worse, can be set to a new value if database is reopened.\r\n        if (!ourSyncNode) {\r\n            return Promise.reject(new Dexie.DatabaseClosedError());\r\n        }\r\n        var LIMIT = 1000;\r\n        var promise = db._changes.where(\"rev\").above(ourSyncNode.myRevision).limit(LIMIT).toArray(function (changes) {\r\n            if (changes.length > 0) {\r\n                var lastChange = changes[changes.length - 1];\r\n                partial = (changes.length === LIMIT);\r\n                db.on('changes').fire(changes, partial);\r\n                ourSyncNode.myRevision = lastChange.rev;\r\n            } else if (wasPartial) {\r\n                // No more changes, BUT since we have triggered on('changes') with partial = true,\r\n                // we HAVE TO trigger changes again with empty list and partial = false\r\n                db.on('changes').fire([], false);\r\n            }\r\n\r\n            let ourNodeStillExists = false;\r\n            return db._syncNodes.where(':id').equals(ourSyncNode.id).modify(syncNode => {\r\n                ourNodeStillExists = true;\r\n                syncNode.lastHeartBeat = Date.now(); // Update heart beat (not nescessary, but why not!)\r\n                syncNode.deleteTimeStamp = null; // Reset \"deleteTimeStamp\" flag if it was there.\r\n                syncNode.myRevision = Math.max(syncNode.myRevision, ourSyncNode.myRevision);\r\n            }).then(()=>ourNodeStillExists);\r\n        }).then(ourNodeStillExists =>{\r\n            if (!ourNodeStillExists) {\r\n                // My node has been deleted. We must have been lazy and got removed by another node.\r\n                if (browserIsShuttingDown) {\r\n                    throw new Error(\"Browser is shutting down\");\r\n                } else {\r\n                    db.close();\r\n                    console.error(\"Out of sync\"); // TODO: What to do? Reload the page?\r\n                    if (global.location) global.location.reload(true);\r\n                    throw new Error(\"Out of sync\"); // Will make current promise reject\r\n                }\r\n            }\r\n\r\n            // Check if more changes have come since we started reading changes in the first place. If so, relaunch readChanges and let the ongoing promise not\r\n            // resolve until all changes have been read.\r\n            if (partial || Observable.latestRevision[db.name] > ourSyncNode.myRevision) {\r\n                // Either there were more than 1000 changes or additional changes where added while we were reading these changes,\r\n                // In either case, call readChanges() again until we're done.\r\n                return readChanges(Observable.latestRevision[db.name], (recursion || 0) + 1, partial);\r\n            }\r\n\r\n        }).finally(function() {\r\n            delete readChanges.ongoingOperation;\r\n        });\r\n\r\n        if (!recursion) {\r\n            readChanges.ongoingOperation = promise;\r\n        }\r\n        return promise;\r\n    }\r\n\r\n    /**\r\n     * The reason we need heartbeat in parallell with poll() is due to the risk of long-running\r\n     * transactions while syncing changes from server to client in Dexie.Syncable. That transaction will\r\n     * include _changes (which will block readChanges()) but not _syncNodes. So this heartbeat will go on\r\n     * during that changes are being applied and update our lastHeartBeat property while poll() is waiting.\r\n     * When cleanup() (who also is blocked by the sync) wakes up, it won't kill the master node because this\r\n     * heartbeat job will have updated the master node's heartbeat during the long-running sync transaction.\r\n     * \r\n     * If we did not have this heartbeat, and a server send lots of changes that took more than NODE_TIMEOUT\r\n     * (20 seconds), another node waking up after the sync would kill the master node and take over because\r\n     * it would believe it was dead.\r\n     */\r\n    function heartbeat() {\r\n        heartbeatHandle = null;\r\n        var currentInstance = mySyncNode.node && mySyncNode.node.id;\r\n        if (!currentInstance) return;\r\n        db.transaction('rw!', db._syncNodes, ()=>{\r\n            db._syncNodes.where({id: currentInstance}).first(ourSyncNode => {\r\n                if (!ourSyncNode) {\r\n                    // We do not exist anymore. Call db.close() to teardown polls etc.\r\n                    if (db.isOpen()) db.close();\r\n                    return;\r\n                }\r\n                ourSyncNode.lastHeartBeat = Date.now();\r\n                ourSyncNode.deleteTimeStamp = null; // Reset \"deleteTimeStamp\" flag if it was there.\r\n                return db._syncNodes.put(ourSyncNode);\r\n            });\r\n        }).catch('DatabaseClosedError', () => {\r\n            // Ignore silently\r\n        }).finally(() => {\r\n            if (mySyncNode.node && mySyncNode.node.id === currentInstance && db.isOpen()) {\r\n                heartbeatHandle = setTimeout(heartbeat, HEARTBEAT_INTERVAL);\r\n            }\r\n        });\r\n    }\r\n\r\n    function poll() {\r\n        pollHandle = null;\r\n        var currentInstance = mySyncNode.node && mySyncNode.node.id;\r\n        if (!currentInstance) return;\r\n        Dexie.vip(function() { // VIP ourselves. Otherwise we might not be able to consume intercomm messages from master node before database has finished opening. This would make DB stall forever. Cannot rely on storage-event since it may not always work in some browsers of different processes.\r\n            readChanges(Observable.latestRevision[db.name]).then(cleanup).then(consumeIntercommMessages)\r\n            .catch('DatabaseClosedError', ()=>{\r\n                // Handle database closed error gracefully while reading changes.\r\n                // Don't trigger 'unhandledrejection'.\r\n                // Even though we intercept the close() method, it might be called when in the middle of\r\n                // reading changes and then that flow will cancel with DatabaseClosedError.\r\n            })\r\n            .finally(function() {\r\n                // Poll again in given interval:\r\n                if (mySyncNode.node && mySyncNode.node.id === currentInstance && db.isOpen()) {\r\n                    pollHandle = setTimeout(poll, LOCAL_POLL);\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    \r\n    function cleanup() {\r\n        var ourSyncNode = mySyncNode.node;\r\n        if (!ourSyncNode) return Promise.reject(new Dexie.DatabaseClosedError());\r\n        return db.transaction('rw', '_syncNodes', '_changes', '_intercomm', function() {\r\n            // Cleanup dead local nodes that has no heartbeat for over a minute\r\n            // Dont do the following:\r\n            //nodes.where(\"lastHeartBeat\").below(Date.now() - NODE_TIMEOUT).and(function (node) { return node.type == \"local\"; }).delete();\r\n            // Because client may have been in hybernate mode and recently woken up. That would lead to deletion of all nodes.\r\n            // Instead, we should mark any old nodes for deletion in a minute or so. If they still dont wakeup after that minute we could consider them dead.\r\n            var weBecameMaster = false;\r\n            db._syncNodes.where(\"lastHeartBeat\").below(Date.now() - NODE_TIMEOUT).filter(node => node.type === 'local').modify(function(node) {\r\n                if (node.deleteTimeStamp && node.deleteTimeStamp < Date.now()) {\r\n                    // Delete the node.\r\n                    delete this.value;\r\n                    // Cleanup localStorage \"deadnode:\" entry for this node (localStorage API was used to wakeup other windows (onstorage event) - an event type missing in indexedDB.)\r\n                    if (localStorage) {\r\n                        localStorage.removeItem('Dexie.Observable/deadnode:' + node.id + '/' + db.name);\r\n                    }\r\n                    // Check if we are deleting a master node\r\n                    if (node.isMaster) {\r\n                        // The node we are deleting is master. We must take over that role.\r\n                        // OK to call nodes.update(). No need to call Dexie.vip() because nodes is opened in existing transaction!\r\n                        db._syncNodes.update(ourSyncNode, { isMaster: 1 });\r\n                        weBecameMaster = true;\r\n                    }\r\n                    // Cleanup intercomm messages destinated to the node being deleted.\r\n                    // Those that waits for reply should be redirected to us.\r\n                    db._intercomm.where({destinationNode: node.id}).modify(function(msg) {\r\n                        if (msg.wantReply)\r\n                            msg.destinationNode = ourSyncNode.id;\r\n                        else\r\n                            // Delete the message from DB and if someone is waiting for reply, let ourselved answer the request.\r\n                            delete this.value;\r\n                    });\r\n                } else if (!node.deleteTimeStamp) {\r\n                    // Mark the node for deletion\r\n                    node.deleteTimeStamp = Date.now() + HIBERNATE_GRACE_PERIOD;\r\n                }\r\n            }).then(function() {\r\n                // Cleanup old revisions that no node is interested of.\r\n                Observable.deleteOldChanges(db);\r\n                return db.on(\"cleanup\").fire(weBecameMaster);\r\n            });\r\n        });\r\n    }\r\n\r\n    function onBeforeUnload() {\r\n        // Mark our own sync node for deletion.\r\n        if (!mySyncNode.node) return;\r\n        browserIsShuttingDown = true;\r\n        mySyncNode.node.deleteTimeStamp = 1; // One millisecond after 1970. Makes it occur in the past but still keeps it truthy.\r\n        mySyncNode.node.lastHeartBeat = 0;\r\n        db._syncNodes.put(mySyncNode.node); // This async operation may be cancelled since the browser is closing down now.\r\n        Observable.wereTheOneDying = true; // If other nodes in same window wakes up by this call, make sure they dont start taking over mastership and stuff...\r\n        // Inform other windows that we're gone, so that they may take over our role if needed. Setting localStorage item below will trigger Observable.onStorage, which will trigger onSuicie() below:\r\n        if (localStorage) {\r\n            localStorage.setItem('Dexie.Observable/deadnode:' + mySyncNode.node.id.toString() + '/' + db.name, \"dead\"); // In IE, this will also wakeup our own window. However, that is doublechecked in nursecall subscriber below.\r\n        }\r\n    }\r\n\r\n    function onSuicide(dbname, nodeID) {\r\n        if (dbname === db.name && !Observable.wereTheOneDying) {\r\n            // Make sure it's dead indeed. Second bullet. Why? Because it has marked itself for deletion in the onbeforeunload event, which is fired just before window dies.\r\n            // It's own call to put() may have been cancelled.\r\n            // Note also that in IE, this event may be called twice, but that doesnt harm!\r\n            Dexie.vip(function() {\r\n                db._syncNodes.update(nodeID, { deleteTimeStamp: 1, lastHeartBeat: 0 }).then(cleanup);\r\n            });\r\n        }\r\n    }\r\n\r\n}\r\n\r\n//\r\n// Static properties and methods\r\n// \r\n\r\nObservable.latestRevision = {}; // Latest revision PER DATABASE. Example: Observable.latestRevision.FriendsDB = 37;\r\nObservable.on = Dexie.Events(null, \"latestRevisionIncremented\", \"suicideNurseCall\", \"intercomm\", \"beforeunload\"); // fire(dbname, value);\r\nObservable.createUUID = createUUID;\r\n\r\nObservable.deleteOldChanges = deleteOldChanges;\r\n\r\nObservable._onStorage = initOnStorage(Observable);\r\n\r\nObservable._onBeforeUnload = function() {\r\n    Observable.on.beforeunload.fire();\r\n};\r\n\r\ntry {\r\n    Observable.localStorageImpl = global.localStorage;\r\n} catch (ex){}\r\n\r\n//\r\n// Map window events to static events in Dexie.Observable:\r\n//\r\nif (global.addEventListener) {\r\n    global.addEventListener(\"storage\", Observable._onStorage);\r\n    global.addEventListener(\"beforeunload\", Observable._onBeforeUnload);\r\n}\r\n// Register addon:\r\nDexie.Observable = Observable;\r\nDexie.addons.push(Observable);\r\n","// Change Types\r\nexport const CREATE = 1;\r\nexport const UPDATE = 2;\r\nexport const DELETE = 3;\r\n","import Dexie from 'dexie';\r\n\r\nexport default function initOnStorage(Observable) {\r\n  return function onStorage(event) {\r\n    // We use the onstorage event to trigger onLatestRevisionIncremented since we will wake up when other windows modify the DB as well!\r\n    if (event.key.indexOf(\"Dexie.Observable/\") === 0) { // For example \"Dexie.Observable/latestRevision/FriendsDB\"\r\n      var parts = event.key.split('/');\r\n      var prop = parts[1];\r\n      var dbname = parts[2];\r\n      if (prop === 'latestRevision') {\r\n        var rev = parseInt(event.newValue, 10);\r\n        if (!isNaN(rev) && rev > Observable.latestRevision[dbname]) {\r\n          Observable.latestRevision[dbname] = rev;\r\n          Dexie.ignoreTransaction(function () {\r\n            Observable.on('latestRevisionIncremented').fire(dbname, rev);\r\n          });\r\n        }\r\n      } else if (prop.indexOf(\"deadnode:\") === 0) {\r\n        var nodeID = parseInt(prop.split(':')[1], 10);\r\n        if (event.newValue) {\r\n          Observable.on.suicideNurseCall.fire(dbname, nodeID);\r\n        }\r\n      } else if (prop === 'intercomm') {\r\n        if (event.newValue) {\r\n          Observable.on.intercomm.fire(dbname);\r\n        }\r\n      }\r\n    }\r\n  };\r\n}\r\n"]}